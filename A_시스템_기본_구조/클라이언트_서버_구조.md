# 클라이언트–서버 구조

초보자도 “클라이언트에서 무슨 일이 일어나고, 서버는 어디까지 책임지며, 둘 사이에 무엇이 오가는지”를 한 번에 이해할 수 있도록 기초부터 차근차근 정리했다.

---

## 1. 왜 클라이언트–서버 구조가 필요할까?

- **역할 분담**: 화면(UI)과 사용자 경험은 클라이언트가, 비즈니스 규칙/데이터 저장/외부 연동은 서버가 담당한다.
- **보안**: 중요한 로직과 데이터는 서버에 숨겨 두고, 클라이언트에는 최소 정보만 남긴다.
- **확장성**: 서버를 여러 대 두거나 캐시·로드 밸런서를 추가해 트래픽 증가에 대응할 수 있다.

---

## 2. 전체 그림부터 잡기

아래 순서를 머릿속에 그려보면 구조가 명확해진다.

```
사용자 브라우저/앱
        │
        ▼
   (1) CDN
        │
        ▼
   (2) 로드 밸런서
        │
        ▼
   (3) API Gateway / BFF
        │
        ▼
   (4) 애플리케이션 서버
        │
        ├─ (5-1) 데이터베이스 / 캐시
        └─ (5-2) 외부 API / 메시지 큐
        │
        ▼
   (6) 응답 직렬화 후 사용자에게 반환
```

각 번호는 독립적인 계층이다. 예를 들어 CDN(1)은 정적 파일을 캐싱해 빠르게 내려주고, 로드 밸런서(2)는 여러 서버로 트래픽을 분배한다.

---

## 3. 구성 요소 상세 설명

| 계층                   | 하는 일                                 | 왜 필요한가                                   |
| ---------------------- | --------------------------------------- | --------------------------------------------- |
| 클라이언트(웹/앱)      | UI 표시, 사용자 입력 수집               | 사용자가 눈으로 보는 부분                     |
| CDN                    | 정적 자산(이미지, JS, CSS) 캐시         | 서버 부하 감소, 지연 최소화                   |
| 로드 밸런서(L4/L7)     | 트래픽 균등 분배, Health Check          | 서버 한 대에 장애가 나도 전체 서비스 유지     |
| API Gateway / BFF      | 인증, 라우팅, 요청/응답 변환            | 다중 클라이언트(B2C/B2B)에 맞게 데이터 재구성 |
| 애플리케이션 서버      | 컨트롤러-서비스-리포지토리, 도메인 로직 | 핵심 비즈니스 구현                            |
| 데이터 저장소/외부 API | RDB, NoSQL, 캐시, 메시지 큐, 서드파티   | 영속성, 통합, 비동기 처리                     |

---

## 4. 대표 토폴로지와 선택 기준

| 구조                           | 설명                                        | 언제 쓰나                             |
| ------------------------------ | ------------------------------------------- | ------------------------------------- |
| **2-Tier** (Client ↔ Server)   | 한 서버가 웹/비즈니스/DB 모두 담당          | PoC, 내부 도구                        |
| **3-Tier** (Client ↔ App ↔ DB) | 웹 서버와 DB 분리                           | 대부분의 서비스 기본형                |
| **N-Tier / BFF**               | Gateway/BFF 추가, 서비스/데이터 계층 세분화 | 조직이 크고 클라이언트 종류가 많을 때 |

규모가 커질수록 레이어를 늘리는 이유는 “각 계층이 잘하는 일만” 집중하게 해 유지보수와 확장성을 높이기 위함이다.

---

## 5. 실제 요청 흐름 예시

1. 사용자가 브라우저에서 `/products`를 요청.
2. DNS→CDN→로드 밸런서를 거쳐 API Gateway로 전달.
3. Gateway가 인증 토큰을 확인 후 `product-service`로 라우팅.
4. 애플리케이션 서버가 캐시 조회 → DB 조회 → 비즈니스 로직 실행.
5. 결과를 JSON으로 직렬화하고 응답 헤더에 캐시 지시자를 포함해 반환.
6. 브라우저는 데이터를 렌더링하고, 필요하면 후속 API를 호출.

---

## 6. 다이어그램 그리는 방법 가이드

처음 다이어그램을 그릴 때 아래 순서를 따라 하면 쉽다.

1. **상자(Box)**: 각 계층이나 컴포넌트를 사각형으로 표현한다 (Client, CDN, LB, Gateway, App, DB 등).
2. **화살표(Arrow)**: 데이터 흐름 방향을 그린다. 요청과 응답을 각각 표시하면 좋다.
3. **주석(Label)**: 화살표 위에 “HTTPS”, “REST JSON”, “gRPC” 같이 프로토콜이나 역할을 적는다.
4. **행위(Sequence)**: 순서도가 필요하면 번호(1,2,3…)를 붙여 서비스 흐름을 나타낸다.
5. **도구**: draw.io, Excalidraw, Miro, Notion Drawings 등 손쉬운 도구를 활용한다.

예시:

```
[Browser] --HTTPS--> [API Gateway] --gRPC--> [Order Service] --SQL--> [DB]
```

이 정도만 해도 요청 흐름을 금방 이해할 수 있다.

---

## 7. 학습용 실습 아이디어

- **연습 1**: 현재 개발 중인 서비스(또는 사이드 프로젝트)를 대상으로 위 다이어그램을 직접 작성해본다.
- **연습 2**: “만약 트래픽이 10배 늘어난다면?”을 가정하고 어느 계층을 먼저 확장할지 정리해본다.
- **연습 3**: 각각의 계층에 장애가 발생했을 때 사용자에게 어떤 증상이 나타나는지 표로 정리한다.

---

## 8. 자주 쓰는 설계/운영 팁

- 초기에 모놀리식이어도 **레이어드 아키텍처**를 지키면 추후 분리하기 쉽다.
- **API 계약서(OpenAPI/Swagger)**를 통해 클라이언트와 서버 간 기대치(필드, 응답 코드)를 문서화한다.
- 배포/장애/성능 지표를 각 계층별로 추적해두어야 병목 지점을 빠르게 발견할 수 있다.

---

## 9. 체크리스트

- [ ] 내 서비스의 주요 컴포넌트를 다이어그램으로 표현했는가?
- [ ] 각 계층의 책임과 데이터 흐름을 글로 설명할 수 있는가?
- [ ] 동기/비동기 경로를 구분해 장애 시 영향 범위를 파악했는가?
- [ ] 인증/인가, TLS 종료, WAF, 네트워크 분리(VPC, 서브넷) 위치를 정의했는가?
- [ ] 확장성 요구사항(목표 QPS, 버스트 대응 전략)을 문서화했는가?
- [ ] 관찰성(로그, 메트릭, 트레이싱) 수집 지점을 지정했는가?
