# Blocking / Non-blocking I/O

I/O 모델은 “스레드가 기다리느냐”뿐 아니라, 시스템 자원과 확장성에 직결된다. 아래 내용을 순차적으로 학습하면 Blocking과 Non-blocking을 제대로 구분하고 적용할 수 있다.

---

## 1. 개념 이해

- **Blocking I/O**
  - 호출 스레드가 결과를 받을 때까지 대기.
  - 소켓/파일에 읽을 데이터가 준비되지 않으면 계속 기다린다.
  - 구조가 단순해 디버깅이 쉬우나, 많은 연결을 동시에 처리하기 어렵다.
- **Non-blocking I/O**
  - 호출 직후 즉시 반환 -> 준비 완료 시 이벤트 루프/콜백/Future가 알림.
  - 한 스레드(이벤트 루프)로도 수천 개 연결을 관리 가능.
  - 코드가 복잡하고 상태/예외 관리가 까다롭다.

---

## 2. 상황별 선택 기준

| 상황                                      | 권장 방식    | 이유                                        |
| ----------------------------------------- | ------------ | ------------------------------------------- |
| 트랜잭션 일관성 최우선, 요청 수가 적음    | Blocking     | 코드 단순, 트랜잭션 경계 관리 쉬움          |
| 대량의 외부 API 호출, WebSocket, SSE      | Non-blocking | 스레드 수 최소화, 높은 동시성               |
| 핵심 경로는 안정성, 부가 작업은 효율 추구 | 혼합         | 중요 작업은 Blocking, 나머지는 Non-blocking |

---

## 3. 어떻게 동작하는지 그림으로 보기

```
[요청 스레드] --읽기--> [소켓]
   │                    │
   ├─ (Blocking)  데이터가 준비될 때까지 스레드 대기
   │
   └─ (Non-blocking)  바로 반환 ─> [이벤트 루프]가 준비 완료 시 콜백 실행
```

이벤트 루프(예: Netty, Node.js)는 등록된 소켓에서 “읽을 준비가 됐는지”를 감시하고, 준비되면 콜백을 실행한다.

---

## 4. 실제 적용 사례

- **Blocking**
  - Spring MVC + JDBC, 전통적인 서블릿 환경.
  - 결제, 송금 등 트랜잭션이 핵심인 업무.
- **Non-blocking**
  - Netty, Spring WebFlux, Node.js, gRPC Async.
  - 알림 발송, 실시간 채팅/스트리밍, 대용량 업로드.
- **혼합**
  - API 게이트웨이(Non-blocking) → 내부 마이크로서비스(Blocking) → 비동기 후처리.

---

## 5. 설계/운영 시 체크포인트

- [ ] 사용하는 웹 서버/프레임워크(Tomcat, Netty 등)의 스레드 모델을 이해했는가?
- [ ] Blocking 라이브러리를 Non-blocking 코드에 사용할 경우, 별도 스레드 풀로 분리했는가?
- [ ] DB/외부 API 드라이버가 Non-blocking을 지원하지 않을 때의 대안을 마련했는가?
- [ ] 스레드 풀 사용량, 큐 길이, 이벤트 루프 지연, 컨텍스트 스위칭 같은 지표를 모니터링하는가?
- [ ] CPU 바운드 작업과 I/O 바운드 작업을 분리해 튜닝했는가?

---

## 6. 실습 아이디어

- **실습 1**: 동일 기능을 Spring MVC(Blocking)와 WebFlux(Non-blocking)로 각각 구현해 비교한다.
- **실습 2**: Netty/Node.js로 WebSocket 서버를 만들어 동시 접속자 수에 따른 스레드 사용량을 측정한다.
- **실습 3**: Blocking 코드가 이벤트 루프에 섞이면 어떻게 병목이 생기는지 지표로 확인해 본다.

---

## 7. 설계 팁

- 기본 전략은 **Non-blocking + Backpressure**이고, SLA가 엄격한 핵심 트랜잭션만 Blocking으로 유지하는 혼합형이 안전하다.
- `@Async`, `CompletableFuture`, Coroutine 등을 사용할 때 **컨텍스트 전파(트랜잭션, Trace, Security)**를 반드시 확인한다.
- 큐 병목이나 다운스트림 장애가 발생하면 임시로 Blocking 호출로 전환하거나, 메시지 큐를 버퍼로 사용하는 **Fallback 절차**를 준비한다.
