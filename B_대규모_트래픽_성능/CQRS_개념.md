# CQRS 구조와 읽기/쓰기 분리

CQRS(Command Query Responsibility Segregation)는 “쓰기 모델과 읽기 모델을 분리”해 확장성과 복잡한 조회 요구를 해결하는 패턴이다.

---

## 1. 왜 CQRS를 쓰나?
- 읽기와 쓰기의 비율/특성이 다를 때 각각을 최적화하기 위해.
- 복잡한 조회(리포트, 대시보드)로 인해 DB 락이 발생하는 것을 줄이기 위해.
- 이벤트 소싱과 결합해 변경 이력을 완전히 기록하기 위해.

---

## 2. 기본 구조
```
[API] ──Command─> [쓰기 모델] ──DB(정규화)
  │
  └─Query──> [읽기 모델] ──별도 DB/캐시(비정규화)

쓰기 이벤트 ──> [동기/비동기] ──> 읽기 모델 동기화
```

쓰기 모델은 도메인 규칙과 트랜잭션을 책임지고, 읽기 모델은 조회 속도에 최적화된 구조를 갖는다.

---

## 3. 동기화 방법
- **이벤트 기반 비동기**: 쓰기 성공 후 이벤트 발행 → 읽기 모델이 구독해 데이터 반영.
- **동기 복제**: 쓰기 요청 내에서 읽기 모델을 즉시 업데이트. 일관성은 높지만 느릴 수 있음.
- **스케줄러**: 일정 주기로 읽기 모델을 최신 상태로 동기화.

---

## 4. 장단점 요약
| 장점 | 단점 |
| --- | --- |
| 읽기/쓰기 각각 독립적 확장 가능 | 설계/운영 복잡도 증가 |
| 조회 형태에 맞춘 비정규화 모델 가능 | 데이터 최종 일관성 문제 |
| 이벤트 소싱과 자연스럽게 결합 | 테스트/디버깅 난이도 상승 |

---

## 5. 체크리스트
- [ ] 읽기/쓰기 비율과 패턴을 분석했는가?
- [ ] 읽기 모델 동기화 지연으로 허용 가능한 범위를 정의했는가?
- [ ] 이벤트 중복/순서 문제에 대비한 멱등 처리 방안을 마련했는가?
- [ ] 운영/배포/모니터링을 두 배로 관리할 준비가 되어 있는가?

---

## 6. 실습 아이디어
- **실습 1**: 간단한 주문 시스템을 CQRS로 나누고, 읽기 모델을 Redis/ElasticSearch로 구성해 본다.
- **실습 2**: 이벤트 지연을 의도적으로 발생시켜 사용자에게 어떤 영향을 주는지 측정한다.
- **실습 3**: 이벤트 소싱을 적용해 시간 순으로 상태를 재구성하는 연습을 한다.

