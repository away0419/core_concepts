# 병목(Bottleneck) 분석 가이드

대규모 트래픽 상황에서 “어디가 가장 느린가?”를 빠르게 찾는 능력은 필수다. 이 문서는 병목을 정의하고, 측정 → 시각화 → 개선 순서를 초보자도 따라 할 수 있게 정리한다.

---

## 1. 병목이란?
- 시스템 전체 성능을 제한하는 가장 느린 구간.
- CPU, 메모리, 디스크 I/O, 네트워크, 데이터베이스, 애플리케이션 코드 등 어디든 존재할 수 있다.
- **Amdahl의 법칙**: 전체 시스템 성능은 병목 구간의 개선 정도에 의해 결정된다.

---

## 2. 분석 절차
1. **문제 정의**: “응답이 느리다”를 “P95가 1초에서 3초로 늘었다”처럼 수치화한다.
2. **모니터링 지표 수집**: CPU 사용률, GC 시간, DB QPS, 캐시 Hit ratio, 네트워크 RTT 등을 한 화면에서 본다.
3. **분산 추적/프로파일링**: 요청 단위로 각 함수/쿼리가 걸린 시간을 시각화한다.
4. **원인 추정 & 실험**: 후보 원인을 하나씩 제거하거나 부하를 조절하면서 변화를 측정한다.
5. **개선 & 회귀 테스트**: 수정 후 같은 시나리오를 다시 실행하여 개선 여부를 검증한다.

---

## 3. 도구 예시
- **APM**: NewRelic, Datadog, Pinpoint, SkyWalking 등.
- **프로파일러**: Java Flight Recorder, perf, eBPF, flame graph.
- **분산 추적**: Jaeger, Zipkin, AWS X-Ray, OpenTelemetry.
- **부하 테스트**: k6, JMeter, Locust, Vegeta.
- **DB 분석**: MySQL slow query log, pg_stat_statements, EXPLAIN.

---

## 4. 실무 체크포인트
- [ ] Latency Budget(Frontend, Gateway, App, DB/Cache) 를 정의해 두었는가?
- [ ] “증상”과 “원인”을 분리하여 기록하는가? (예: CPU 90%는 증상일 뿐)
- [ ] 실험 전/후 동일한 데이터셋과 부하 패턴으로 비교했는가?
- [ ] 개선 내용을 ADR/Runbook으로 문서화해 재발 시 바로 참고할 수 있게 했는가?

---

## 5. 학습/실습 아이디어
- **실습 1**: 샘플 애플리케이션에 부하를 주고 flame graph를 그려 병목 함수를 찾는다.
- **실습 2**: 캐시를 끄거나 DB 인덱스를 제거해 고의로 병목을 만들고 관찰 지표를 기록한다.
- **실습 3**: Latency Budget 표를 작성하고, 각 구간의 목표치를 팀과 리뷰한다.

