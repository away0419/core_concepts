# 전반적 퍼포먼스 튜닝 체크포인트

대규모 트래픽을 안정적으로 처리하려면 DB 쿼리, 비동기/배치, 커넥션 풀, 메모리/GC까지 폭넓게 점검해야 한다. 이 문서는 필수 체크 항목을 묶어 정리했다.

---

## 1. 데이터베이스 쿼리 최적화
- **Execution Plan**: `EXPLAIN`/`EXPLAIN ANALYZE`로 인덱스 사용 여부와 조인 순서를 확인.
- **인덱스 설계**: 선택도가 높은 컬럼, 커버링 인덱스, 복합 인덱스 순서를 점검.
- **캐싱**: 읽기 부하가 높은 쿼리는 캐시나 Materialized View로 전환.
- **샤딩/파티셔닝**: 데이터 크기가 커질수록 범위 스캔을 줄이기 위해 파티션 키 설계.

## 2. 비동기/배치 처리
- 실시간 응답이 필요 없는 작업은 큐/배치를 사용해 피크 타임 부하를 분산.
- 배치 작업 시간대를 모니터링하고, 운영 시간과 겹치면 트래픽 분산/슬라이싱.
- 비동기 작업 상태를 추적할 수 있는 대시보드와 재처리 기능을 준비.

## 3. 커넥션 풀
- 풀 크기를 무작정 늘리면 오히려 DB가 과부하. “(DB CPU 코어 수 × 2) + 디스크” 등 공식으로 시작해 모니터링을 통해 조정.
- 풀 대기 시간, 사용률, 생성/종료 속도를 지표로 관리.
- 장시간 미사용 커넥션이나 유출(leak)을 탐지하는 툴 사용.

## 4. 메모리/GC 튜닝
- JVM: G1/ZGC 등 GC 선택, 힙 사이즈, 메타스페이스 점검.
- Native: malloc/free 패턴, huge pages, NUMA 설정.
- 메모리 프로파일러(VisualVM, YourKit 등)로 객체 생명주기를 분석해 단기 객체 생성을 줄인다.

---

## 5. 체크리스트
- [ ] 상위 N개 느린 쿼리와 그 원인을 문서화했는가?
- [ ] 비동기/배치 작업이 장애 시 서비스에 어떤 영향을 주는지 정의했는가?
- [ ] 커넥션 풀 지표(활성/대기/거부)를 모니터링하고 임계치 알림을 설정했는가?
- [ ] GC Pausetime, 힙 사용률, 메모리 누수를 주기적으로 점검하는가?

---

## 6. 실습 아이디어
- **실습 1**: 실제 쿼리를 EXPLAIN으로 분석하고 인덱스를 추가한 뒤 성능 차이를 측정.
- **실습 2**: 큐 기반 비동기 처리와 동기 처리의 CPU/응답 시간 차이를 비교.
- **실습 3**: 커넥션 풀 크기를 달리하면서 DB와 애플리케이션 지표가 어떻게 변하는지 실험.

