# 이벤트 기반 아키텍처 (Event-driven Architecture)

서비스 간 결합도를 줄이고 확장성을 높이는 대표적인 방식. 이 문서는 이벤트 기반 아키텍처의 핵심 개념, 패턴, 주의사항을 설명한다.

---

## 1. 기본 개념
- **Event**: 시스템에서 발생한 사실(예: 주문 생성됨). 변경을 알리고 다른 서비스가 반응할 수 있게 한다.
- **Producer**: 이벤트를 발행하는 주체.
- **Consumer**: 이벤트를 구독해 작업을 수행하는 서비스.
- **Broker**: Kafka, RabbitMQ, NATS 같은 메시지 시스템.

---

## 2. 이벤트 흐름 예시
```
[주문 서비스] --OrderCreated--> [Kafka Topic]
    │                              │
    ├─> [재고 서비스] <------------┘
    └─> [알림 서비스]
```

각 소비자는 자신의 속도로 이벤트를 소비하므로, 서비스 간 직접 의존도가 낮아진다.

---

## 3. 주요 패턴
- **Event Notification**: “무엇이 일어났다”만 알림 (간단, 하지만 추가 조회 필요).
- **Event-carried State Transfer**: 이벤트에 상태 데이터를 포함 (추가 조회 없이 처리).
- **Event Sourcing**: 상태 대신 이벤트 로그를 저장하고, 재생해 상태를 재구성.
- **Choreography vs Orchestration**: 분산 트랜잭션을 이벤트로 조율할지, 중앙 오케스트레이터를 둘지 결정.

---

## 4. 주의할 점
- **일관성**: 이벤트 지연/중복/순서 꼬임에 대비한 멱등 처리와 재처리 전략이 필수.
- **스키마 관리**: 이벤트 버전 관리와 호환성 테스트.
- **관찰성**: Trace ID/Span ID를 이벤트에 포함해 end-to-end 추적 가능하게 한다.
- **Backpressure**: 소비자가 따라오지 못할 때 큐 길이·지연을 관찰하고, 스케일링/드롭 정책을 세운다.

---

## 5. 체크리스트
- [ ] 이벤트 명명 규칙과 스키마(필드, 타입, 버전)를 문서화했는가?
- [ ] 멱등성 키, 재처리(DLQ), 순서 보장 전략을 마련했는가?
- [ ] 브로커 장애 대비(Replication, Monitoring, Retention 설정)를 해 두었는가?
- [ ] 이벤트와 명령(Command)을 구분하고 있는가?

---

## 6. 실습 아이디어
- **실습 1**: Kafka로 주문/재고 서비스를 구현하고 이벤트 지연 시나리오를 분석한다.
- **실습 2**: DLQ를 만들어 실패 이벤트를 재처리하는 플로우를 구축한다.
- **실습 3**: Debezium 등 CDC(Change Data Capture)를 이용해 DB 변경을 이벤트로 발행해 본다.

