# 인덱스 동작 원리

인덱스는 책의 목차처럼 특정 데이터를 빠르게 찾게 해준다. 이 문서는 인덱스 내부 구조와 설계 시 주의할 점을 정리한다.

---

## 1. B-Tree 인덱스
- 대부분의 RDBMS에서 기본으로 사용.
- 노드는 정렬된 키와 자식 포인터를 보유 → O(log N) 탐색.
- 리프 노드는 양방향 링크로 연결되어 범위 스캔에 유리.

## 2. Hash 인덱스
- 키를 해시로 변환해 위치를 찾는다.
- 정확한 키 조회에는 빠르지만 범위 검색/정렬에는 부적합.

## 3. 기타 인덱스
- **GIN/GiST**: PostgreSQL에서 JSON, 배열, 공간 데이터 등 특수 자료형 지원.
- **Full-text Index**: 단어를 분리해 검색 성능 최적화.
- **Covering Index**: 필요한 컬럼을 모두 포함해 테이블 접근 없이 결과 제공.

---

## 4. 설계 팁
- **선택도(Selectivity)**가 높은 컬럼을 앞에 둔다.
- 다중 컬럼 인덱스는 “왼쪽 접두사”만 사용 가능하므로 쿼리 패턴과 동일한 순서로 정렬.
- 너무 많은 인덱스는 쓰기 성능을 떨어뜨리고 저장 공간을 낭비.
- 인덱스 재구성/통계 갱신을 주기적으로 수행.

---

## 5. 체크리스트
- [ ] 느린 쿼리에 맞는 인덱스가 존재하는가? (EXPLAIN으로 확인)
- [ ] 중복/미사용 인덱스를 주기적으로 제거하는가?
- [ ] 인덱스 컬럼이 함수/변환에 의해 사용 불가 상태가 아닌가?
- [ ] 대량 삽입/배치 작업 시 인덱스 부담을 줄이는 전략을 갖고 있는가?

---

## 6. 실습 아이디어
- **실습 1**: EXPLAIN(ANALYZE)로 인덱스 사용 여부를 확인하고, 인덱스를 추가/삭제해 실행 계획을 비교.
- **실습 2**: 복합 인덱스 순서를 바꿨을 때 쿼리 성능이 어떻게 변하는지 실험.
- **실습 3**: JSON/Full-text 인덱스를 만들어 특수 검색을 수행.

