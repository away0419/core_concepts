# Lock & Deadlock

동시성 환경에서 데이터 무결성을 지키기 위해서는 Lock을 이해해야 한다. 이 문서는 Lock 종류, 데드락 발생 원인, 해결 전략을 설명한다.

---

## 1. Lock의 종류
- **Shared Lock (S)**: 읽기용 락, 다른 읽기와 공유 가능.
- **Exclusive Lock (X)**: 쓰기용 락, 다른 어떤 락도 허용하지 않음.
- **Intent Lock**: 테이블 수준 의도 락, 하위 레코드 락과 조합.
- **Range Lock / Gap Lock**: 범위 기반 검색 시 Phantom Read를 방지.

---

## 2. Deadlock이란?
- 두 트랜잭션이 서로 상대의 락을 기다려 영원히 진행되지 못하는 상태.
- DBMS는 주기적으로 데드락을 감지하고 한 트랜잭션을 강제로 종료한다.

### 발생 예시
1. 트랜잭션 A가 Row1을 잠금.
2. 트랜잭션 B가 Row2를 잠금.
3. A가 Row2를 요청하지만 B가 가지고 있어 대기.
4. B가 Row1을 요청하지만 A가 가지고 있어 대기 → 데드락.

---

## 3. 예방/해결 전략
- **락 획득 순서 고정**: 항상 동일한 순서로 리소스를 잠근다.
- **짧은 트랜잭션**: 필요한 행만 포함하고 빠르게 커밋.
- **낮은 격리 수준**: Repeatable Read보다 Read Committed가 락 충돌이 적다.
- **낙관적 락(Optimistic Lock)**: 버전 컬럼으로 충돌 감지 후 재시도.
- **DB 설정**: InnoDB `innodb_lock_wait_timeout`, PostgreSQL `deadlock_timeout`.

---

## 4. 체크리스트
- [ ] 데드락 로그를 모니터링하고 있는가?
- [ ] 트랜잭션이 필요 이상으로 많은 행을 잠그지 않는가?
- [ ] 낙관적 락/버전 컬럼으로 사용자 피드백을 제공하는가?
- [ ] 재시도 로직과 지수 백오프를 구현했는가?

---

## 5. 실습 아이디어
- **실습 1**: 두 세션에서 의도적으로 교차 업데이트를 수행해 데드락을 발생시키고 로그를 확인.
- **실습 2**: 락을 오래 잡고 있는 쿼리를 모니터링하고, 트랜잭션 길이를 단축하는 방법을 찾는다.
- **실습 3**: 낙관적 락을 적용한 API를 만들어 충돌 처리 흐름을 익힌다.

